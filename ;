import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import glob
import os

# ---------------------------------------------------------
# Configuration
# ---------------------------------------------------------
NX, NY = 400, 200          # Domain dimensions
sub_steps = 100             # Number of particle updates per velocity file
# Collect velocity file names (assumed to be sorted in order)
velocity_files = sorted(glob.glob("output/velocity/velocity_*.bin"))
num_macro = len(velocity_files)
total_anim_frames = num_macro * sub_steps

# ---------------------------------------------------------
# Particle Initialization
# ---------------------------------------------------------
num_particles = 200
particle_x = np.random.rand(num_particles) * (NX - 300)
particle_y = np.random.rand(num_particles) * (NY - 1)

# For a simple tracer, we update particles directly with the fluid velocity
particle_vx = np.zeros(num_particles)
particle_vy = np.zeros(num_particles)

# Global variable to store the current velocity field (shape: (NY, NX, 2))
current_velocity = None  # will be loaded as a NumPy array

def load_velocity_field(filename):
    """
    Load velocity field from a raw binary file.
    Expected shape is (NY, NX, 2) and dtype is float32.
    """
    data = np.fromfile(filename, dtype=np.float32)
    expected = NY * NX * 2
    if data.size != expected:
        raise ValueError(f"File {filename} size mismatch: got {data.size}, expected {expected}")
    return data.reshape((NY, NX, 2))

# ---------------------------------------------------------
# Helper: Bilinear Interpolation Function
# ---------------------------------------------------------
def bilinear_interpolation(field, x, y):
    """
    Given a 2D field (shape: (NY, NX)), interpolate its value at float coordinates (x, y).
    x is column index, y is row index.
    """
    # Clamp coordinates
    x = np.clip(x, 0, NX - 1)
    y = np.clip(y, 0, NY - 1)
    x0 = int(np.floor(x))
    x1 = min(x0 + 1, NX - 1)
    y0 = int(np.floor(y))
    y1 = min(y0 + 1, NY - 1)
    dx = x - x0
    dy = y - y0

    val00 = field[y0, x0]
    val10 = field[y0, x1]
    val01 = field[y1, x0]
    val11 = field[y1, x1]
    
    val0 = val00 * (1 - dx) + val10 * dx
    val1 = val01 * (1 - dx) + val11 * dx
    return val0 * (1 - dy) + val1 * dy

# ---------------------------------------------------------
# Particle Update Function
# ---------------------------------------------------------
def update_particles(dt):
    """
    Update particles positions for a time step dt.
    Uses the global variable current_velocity (shape: (NY, NX, 2)).
    Applies bilinear interpolation and simple Euler integration.
    Also performs elastic reflections at domain boundaries.
    """
    global particle_x, particle_y, particle_vx, particle_vy, current_velocity
    
    # For each particle:
    for i in range(num_particles):
        # Interpolate fluid velocity at particle's current position
        ux = bilinear_interpolation(current_velocity[..., 0], particle_x[i], particle_y[i])
        uy = bilinear_interpolation(current_velocity[..., 1], particle_x[i], particle_y[i])
        # For tracer particles, set particle velocity to the fluid velocity
        particle_vx[i] = ux
        particle_vy[i] = uy
        
        # Euler update: new position = old position + dt * velocity
        new_x = particle_x[i] + dt * particle_vx[i]
        new_y = particle_y[i] + dt * particle_vy[i]
        
        # Check for collisions with domain boundaries and reflect if necessary
        if new_x < 0:
            new_x = -new_x
            particle_vx[i] = -particle_vx[i]
        elif new_x >= NX:
            overshoot = new_x - (NX - 1)
            new_x = NX - 1 - overshoot
            particle_vx[i] = -particle_vx[i]
        if new_y < 0:
            new_y = -new_y
            particle_vy[i] = -particle_vy[i]
        elif new_y >= NY:
            overshoot = new_y - (NY - 1)
            new_y = NY - 1 - overshoot
            particle_vy[i] = -particle_vy[i]
        
        particle_x[i] = new_x
        particle_y[i] = new_y

# ---------------------------------------------------------
# Matplotlib Animation Setup
# ---------------------------------------------------------
fig, ax = plt.subplots(figsize=(10, 6))

# For demonstration, compute a "speed" field from the current velocity.
# (We'll update the background when the macro velocity frame changes.)
# For now, initialize with zeros.
speed_field = np.zeros((NY, NX))
img = ax.imshow(speed_field, origin='lower', cmap='jet',
                extent=[0, NX, 0, NY], aspect='equal')
fig.colorbar(img, ax=ax, label='Flow Speed')

# Create scatter plot for particles
scatter = ax.scatter(particle_x, particle_y, s=10, c='black')

ax.set_xlim(0, NX)
ax.set_ylim(0, NY)
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_title("Particle Advection in LBM Flow Field")

# Global variable to track current macro frame index
current_macro_index = -1

def animate(frame):
    """
    Animation update function.
    Each animation frame does one particle update sub-step.
    Every 'sub_steps' frames, load the next velocity field.
    """
    global current_velocity, current_macro_index
    
    # Determine which macro frame we are in:
    macro_index = frame // sub_steps
    print(f"macro_index: {macro_index} at frame: {frame}")
    sub_frame = frame % sub_steps  # not used explicitly, but available
    
    # If we've advanced to a new macro frame, load the corresponding velocity field.
    if macro_index != current_macro_index:
        current_macro_index = macro_index
        filename = velocity_files[macro_index]
        current_velocity = load_velocity_field(filename)
        # Also update the background image for flow speed
        speed = np.sqrt(current_velocity[..., 0]**2 + current_velocity[..., 1]**2)
        img.set_data(speed)
    
    # Update particle positions with a chosen dt (adjust as needed)
    dt = 10.0  # time step; adjust to taste
    update_particles(dt)
    
    # Update scatter plot with new positions
    scatter.set_offsets(np.column_stack((particle_x, particle_y)))
    return scatter, img

ani = animation.FuncAnimation(fig, animate, frames=total_anim_frames,
                              interval=50, blit=False)

plt.show()

